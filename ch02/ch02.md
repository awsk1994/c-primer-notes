# Chapter 2: Variables and Basic Types

### 2.2.1. Arithmetic Types

 - 2 categories: integral types (incl character and boolean types) and floating-point types

 - Types: 
   - bool, char, wchar_t, char16_t, char32_t, short, int, long, long long, float, double, long double.

   - char type is guaranteed to be big enough to hold numeric values corresponding to the characters in the machine's **basic** character set.
   - wchar_t type is guaranteed to be large enough to hold any character in the machine's **largest** extended cahracter set.
   - char16_t and char32_t are intended for Unicode characters.
   - numerical types based on integer range: short <= int <= long <= long long

**Signed and Unsigned Types**

 - except for bool and character, the integral types may be signed or unsigned.
 - **signed** represent negative or positive numbers (including 0)
 - **unsigned** represent only values greater than or equal to zero.

 - There are two types of char; signed and unsigned char. The default char is one of these two, and which one it is depends on the compiler.

### 2.1.2. Type Conversion

```cpp
bool b = 42;  // b is true
int i = b;    // i has value 1
i = 3.14;     // i has value 3
double pi = i; // pi has value 3.0.
unsigned char c = -1; // assume 8-bit chars, c has value 255.
signed char c2 = 256; // assume 8-bit chars, the value of c2 is undefined.
```
```cpp
int i = 24;
if(i) // condition will evaluate as true
  i = 0;
```

**Character and Character String Literals:**

 - Compiler appends a null character ('\\0') to every string literal.
 - Thus, the actual size of a string literal is one more than its apparent size.
 - Eg: 'A' represents a single character, but string literal "A" represents an array of two characters; letter 'A' and null character.

**Escape Sequences**

 - We can write a generalized escape sequence, which is \x followed by one or more hexidecimal digits or a \ followed by one, two or three octal digits.

 For example:
 ```
 \115 ('M')
 \x4d ('M')
 ```
 ```cpp
 std::cout << "Hi \x4dO\115!\n"
;
// print: Hi MOM!!(newline)
```

## 2.2. Variables

### 2.2.1. Variable Definitions

 - Each name has a type and name of variable. A definition may (optionally) provide initial value.

```cpp
int sum = 0, value, units_sold = 0; // sum, value and units_sold have type int. sum and units_sold are initialized to 0.
Sales_item item;
std::string book("abc");
```
 - Definition of book uses **std::string** library type. Similar to iostream, string is defined in namespace **std**. 

**List Initialization**

We can use any of the following 4 ways to define an int variable name units_sold:

```cpp
int units_sold = 0;
int units_sold = {0};
int units_sold{0};
int units_sold(0);
```

 - The use of curly braces is a new standard. 
 - Note that compiler will not let us initialize variables of build-in type if initializer might lead to loss of information: For example:

```cpp
long double ld = 3.1415926536;
int a{ld}, b = {ld}; // ERROR: loss of information
int c(ld), d = ld; // OK: but value will be truncated/loss of information
```

**Default Initialization**

 - When we define a variable without an initializer, the variable is **default initialized**. 
 - The value of a **build-in type** that is not explicitly initialized depends on where it is defined. 
   - If outside any function body, it's initialized to zero (with 1 exception; will be covered later)
   - If inside any function body, it's initialized to undefined; thus, is an error to copy or access.
 - For **custom classes**, it depends on the class itself. 
   - Most classes let us define objects with explicit initializers.
   - Eg. uninitialized string is an empty string.

# 2.2.2. Variable Declarations and Definitions

 - **Separate Compilation** lets us split our program into several files, each of which can be compiled independently.
   - When we separate the program into multiple files, we need a way to share the code across the files.
   - For example, code defined in one file may need to use a variable in another file, in the form of a library. Eg: std::cout.
   - To support separate compilation, C++ **distinguishes betweeen** declaration and definition.
 - A **declaration** makes a name known to the program. 
   - A file that wants to use a name defined elsewhere includes a declaration for that name.
   - Specifies **type** and **name** 
 - A **definition** creates the associated entity.
   - Is a declaration. In addition, also **allocates storage and may provide initial value**.
 - We use **extern** to obtain a declaraction that is not also a definition.

```cpp
extern int i; // declares but does not define i
int j; // declares and defines j
```

 - We can provide an initialize value to an extern variable, but doing so **overrides** the extern.

```cpp
extern double pi = 3.1416; // definition
```

 - *It is an error to provide an initializer on an extern inside a function.*

 - Note that **Variables must be defined exactly once, but can be declared many tiems.**

**Final Note**

 - To use the same variable in multiple files, we must **define that variable in one (and only one) file.**
 - Other files that use that variable must **declare, but not define** that variable.

### 2.2.3. Identifiers

 - Identifiers must **begin with either a letter or an underscore**, is **case-sensitive**.

**Conventions**

 - Variable names are normally lowercase; eg. index.
 - Class names usually begin with uppercase letter; eg. Sales_item
 - Identifiers with multiple words should visually distinguish each word; eg. student_loan or studentLoan, NOT studentloan.

 ### 2.2.4. Scope of a name

 - A **scope** is a part of the program in which a name has a particular meaning.
   - Most scopes in C++ are delimited by curly braces.

```cpp
#include <iostream>
int reused = 42;

int main()
{
  int unique = 0;
  std::cout << reused << " " << unique << std::endl;  // out 1: prints 42 0
  int reused = 0; // new, local object named reused, hides global reused.
  std::cout << reused << " " << unique << std::endl;  // out 2: prints 0 0
  std::cout << ::reused << " " << unique << std::endl;  // explicitly requests global scope; out 3: prints 42 0
  return 0;
}
```
 - output #3 uses the scope operator to override the default scoping rules.
   - For more information, you can check out: https://www.geeksforgeeks.org/scope-resolution-operator-in-c/
